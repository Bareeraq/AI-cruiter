import google.generativeai as genai
import PyPDF2
import docx
import json
import os
import re
import pymongo
import logging
from pymongo import MongoClient
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# Load environment variables
load_dotenv(dotenv_path=os.getenv("ENV_PATH", "./config/.env"))

# Configure Gemini API key
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
if not os.getenv("GEMINI_API_KEY"):
    raise ValueError("GEMINI_API_KEY environment variable is not set.")

# MongoDB URI
mongo_uri = os.getenv("MONGO_URI", "mongodb://localhost:27017/")
if not mongo_uri:
    raise ValueError("MONGO_URI environment variable is not set.")

DB_NAME = os.getenv("DATABASE_NAME", "resumes")
COLLECTION_NAME = os.getenv("COLLECTION_NAME_RESUME_DATABASE", "resume_database")

# Initialize MongoDB client
try:
    client = MongoClient(mongo_uri)
    db = client[DB_NAME]
    collection = db[COLLECTION_NAME]
    logging.info(f"Successfully connected to MongoDB database: {DB_NAME}")
except Exception as e:
    logging.critical(f"Error connecting to MongoDB: {e}", exc_info=True)
    raise

# Utility functions
def extract_text_from_docx(docx_file_path):
    try:
        doc = docx.Document(docx_file_path)
        return "\n".join([paragraph.text for paragraph in doc.paragraphs])
    except Exception as e:
        logging.error(f"Error extracting text from DOCX: {e}")
        raise

def extract_text_from_pdf(pdf_file_path):
    try:
        with open(pdf_file_path, "rb") as file:
            reader = PyPDF2.PdfReader(file)
            return "\n".join([page.extract_text() for page in reader.pages])
    except Exception as e:
        logging.error(f"Error extracting text from PDF: {e}")
        raise

def load_prompt(file_path):
    try:
        with open(file_path, "r") as prompt_file:
            return prompt_file.read()
    except FileNotFoundError:
        raise FileNotFoundError(f"Prompt file not found: {file_path}")
    except Exception as e:
        raise Exception(f"Error reading prompt file: {e}")

def analyze_resume_text(resume_text):
    try:
        prompt_file_path = os.path.join("config", "extractor_prompt.txt")
        prompt_template = load_prompt(prompt_file_path)
        prompt = prompt_template.format(resume_text=resume_text)
        model = genai.GenerativeModel("gemini-1.5-flash")
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        logging.error(f"Error analyzing resume text with Gemini: {e}", exc_info=True)
        raise

def clean_gemini_output(response_text):
    if not response_text:
        return {"error": "No content generated by the model."}
    try:
        structured_info = {}
        experience_in_skills = {}

        for line in response_text.split("\n"):
            if ":" in line:
                key, value = line.split(":", 1)
                key_clean = re.sub(r'\*\*|\*|\"|\d+\.\s*', '', key).strip()
                value_clean = re.sub(r'\*\*|\*|\"', '', value).strip()
                value_clean = value_clean.rstrip(',')

                if key_clean == "Experience in Skills":
                    try:
                        experience_in_skills = json.loads(value_clean)
                        if not isinstance(experience_in_skills, dict):
                            experience_in_skills = {}
                    except json.JSONDecodeError:
                        for skill_line in value_clean.split(","):
                            skill_line = skill_line.strip()
                            if ":" in skill_line:
                                skill, years = skill_line.split(":", 1)
                                experience_in_skills[skill.strip()] = years.strip()
                    structured_info[key_clean] = experience_in_skills
                elif key_clean and value_clean:
                    if re.match(r"^\d+\+$", value_clean):
                        experience_in_skills[key_clean] = value_clean
                    elif re.match(r"^\d+(\.\d+)?$", value_clean):
                        numeric_value = float(value_clean) if "." in value_clean else int(value_clean)
                        experience_in_skills[key_clean] = numeric_value
                    else:
                        structured_info[key_clean] = value_clean

        structured_info["Experience in Skills"] = experience_in_skills
        return structured_info
    except Exception as e:
        logging.error(f"Error cleaning Gemini output: {e}", exc_info=True)
        raise

def process_resume(file_path):
    try:
        if file_path.endswith((".pdf", ".PDF")):
            resume_text = extract_text_from_pdf(file_path)
        elif file_path.endswith((".docx", ".doc")):
            resume_text = extract_text_from_docx(file_path)
        else:
            raise ValueError("Unsupported file format")
        return clean_gemini_output(analyze_resume_text(resume_text))
    except Exception as e:
        logging.error(f"Error processing resume: {file_path}, {e}", exc_info=True)
        raise

def extract_resume_data(file_path, store_in_mongodb=False):
    try:
        if os.path.isfile(file_path):
            processed_data = process_resume(file_path)
            if store_in_mongodb:
                if not collection.find_one({"Email Address": processed_data.get("Email Address")}):
                    result = collection.insert_one(processed_data)
                    processed_data["_id"] = str(result.inserted_id)
                else:
                    existing_entry = collection.find_one({"Email Address": processed_data.get("Email Address")})
                    processed_data["_id"] = str(existing_entry["_id"])
            return json.dumps(processed_data, indent=4)
        elif os.path.isdir(file_path):
            results = {}
            for filename in os.listdir(file_path):
                file_full_path = os.path.join(file_path, filename)
                if filename.endswith((".pdf", ".PDF", ".docx", ".doc")):
                    try:
                        parsed_data = process_resume(file_full_path)
                        if store_in_mongodb:
                            if not collection.find_one({"Email Address": parsed_data.get("Email Address")}):
                                result = collection.insert_one(parsed_data)
                                parsed_data["_id"] = str(result.inserted_id)
                            else:
                                existing_entry = collection.find_one({"Email Address": parsed_data.get("Email Address")})
                                parsed_data["_id"] = str(existing_entry["_id"])
                        results[filename] = parsed_data
                    except Exception as e:
                        results[filename] = {"error": str(e)}
            return json.dumps(results, indent=4)
        else:
            raise ValueError("Invalid path")
    except Exception as e:
        return json.dumps({"error": f"Error in extract_resume_data: {str(e)}"})

def upsert_into_mongodb(data):
    email = data.get("Email Address")
    if not email:
        logging.warning("Email Address not found in extracted data.")
        return
    try:
        existing_entry = collection.find_one({"Email Address": email})
        if existing_entry:
            collection.update_one({"_id": existing_entry["_id"]}, {"$set": data})
            logging.info(f"Updated resume for {email}")
        else:
            collection.insert_one(data)
            logging.info(f"Inserted resume for {email}")
    except pymongo.errors.PyMongoError as e:
        logging.error(f"MongoDB error: {e}", exc_info=True)
